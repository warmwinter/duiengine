#pragma once
// Start of DuiEngine namespace section
namespace DuiEngine
{
	class CDuiWindow;

/*!
\brief
	Base class used as the argument to all subscribers Event object.

	The base EventArgs class does not contain any useful information, it is intended
	to be specialised for each type of event that can be generated by objects within
	the system.  The use of this base class allows all event subscribers to have the
	same function signature.

	The \a handled field is used to signal whether an event was actually handled or not.  While
	the event system does not look at this value, code at a higher level can use it to determine
	how far to propagate an event.
*/
class EventArgs
{
public:
	/*************************************************************************
		Construction
	*************************************************************************/
	EventArgs(LPNMHDR pnms,CDuiWindow *pSender) 
		: handled(0)
		, m_pnms(pnms)
		, m_pSender(pSender)
	{}
	virtual ~EventArgs(void) {}

	LPNMHDR m_pnms;

	CDuiWindow *m_pSender;
	/*************************************************************************
		Data members
	*************************************************************************/
    //! handlers should increment this if they handled the event.
    UINT handled;
};

enum _SLOTTYPE{SLOT_FUN,SLOT_MEMBER};
/*!
\brief
    Defines abstract interface which will be used when constructing various
    functor objects that bind slots to signals (or in CEGUI terms, handlers to
    events).
*/
class DUI_EXP SlotFunctorBase
{
public:
    virtual ~SlotFunctorBase() {};
    virtual bool operator()(const EventArgs& args) = 0;
	virtual SlotFunctorBase* Clone() const =0;
	virtual bool Equal(const SlotFunctorBase & sour)const  =0;
	virtual UINT GetSlotType() const  =0;
};

/*!
\brief
    Slot functor class that calls back via a free function pointer.
*/
class DUI_EXP FreeFunctionSlot : public SlotFunctorBase
{
public:
    //! Slot function type.
    typedef bool (SlotFunction)(const EventArgs&);

    FreeFunctionSlot(SlotFunction* func) :
        d_function(func)
    {}

    virtual bool operator()(const EventArgs& args)
    {
        return d_function(args);
    }

	virtual SlotFunctorBase* Clone() const 
	{
		return new FreeFunctionSlot(d_function);
	}

	virtual bool Equal(const SlotFunctorBase & sour)const 
	{
		if(sour.GetSlotType()!=SLOT_FUN) return false;
		const FreeFunctionSlot *psour=static_cast<const FreeFunctionSlot*>(&sour);
		DUIASSERT(psour);
		return psour->d_function==d_function;
	}

	virtual UINT GetSlotType() const {return SLOT_FUN;}

private:
    SlotFunction* d_function;
};

/*!
\brief
    Slot template class that creates a functor that calls back via a class
    member function.
*/
template<typename T>
class MemberFunctionSlot : public SlotFunctorBase
{
public:
    //! Member function slot type.
    typedef bool(T::*MemberFunctionType)(const EventArgs&);

    MemberFunctionSlot(MemberFunctionType func, T* obj) :
        d_function(func),
        d_object(obj)
    {}

    virtual bool operator()(const EventArgs& args)
    {
        return (d_object->*d_function)(args);
    }

	virtual SlotFunctorBase* Clone() const 
	{
		return new MemberFunctionSlot(d_function,d_object);
	}

	virtual bool Equal(const SlotFunctorBase & sour)const 
	{
		if(sour.GetSlotType()!=SLOT_MEMBER) return false;
		const MemberFunctionSlot *psour=static_cast<const MemberFunctionSlot*>(&sour);
		DUIASSERT(psour);
		return psour->d_function==d_function && psour->d_object==d_object;
	}

	virtual UINT GetSlotType()const {return SLOT_MEMBER;}

private:
    MemberFunctionType d_function;
    T* d_object;
};

template <class T>
MemberFunctionSlot<T> Subscriber( bool (T::* pFn)(const EventArgs &), T* pObject)
{
	return MemberFunctionSlot<T>(pFn,pObject);
}

inline FreeFunctionSlot Subscriber(bool (*pFn)(const EventArgs &))
{
	return FreeFunctionSlot(pFn); 
}

} // End of  CEGUI namespace section